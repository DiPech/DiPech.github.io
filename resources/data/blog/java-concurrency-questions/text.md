## 1. What is inside concurrency package?

![](/resources/data/blog/java-concurrency-questions/java-util-concurrent.png)

**Concurrent Collections**

Набор коллекций, более эффективно работающие в многопоточной среде нежели стандартные универсальные коллекции из java.util пакета. Вместо базового враппера Collections.synchronizedList с блокированием доступа ко всей коллекции **используются блокировки по сегментам данных** или же **оптимизируется работа для параллельного чтения данных** по wait-free алгоритмам.

- CopyOnWriteArrayList
- CopyOnWriteArraySet
- ConcurrentHashMap
- ConcurrentLinkedQueue
- ConcurrentLinkedDeque
- ArrayBlockingQueue
- DelayQueue
- LinkedBlockingQueue
- PriorityBlockingQueue
- SynchronousQueue

**Queues**

Неблокирующие и блокирующие очереди с поддержкой многопоточности. Неблокирующие очереди заточены на скорость и работу без блокирования потоков. Блокирующие очереди используются, когда нужно «притормозить» потоки «Producer» или «Consumer», если не выполнены какие-либо условия, например, очередь пуста или перепонена, или же нет свободного «Consumer»'a.

- ConcurrentLinkedQueue
- ConcurrentLinkedDeque
- ArrayBlockingQueue
- DelayQueue
- LinkedBlockingQueue
- PriorityBlockingQueue
- SynchronousQueue

**Synchronizers**

Вспомогательные утилиты для синхронизации потоков. Представляют собой мощное оружие в «параллельных» вычислениях.

- Semaphore
- CountDownLatch
- CyclicBarrier
- Exchanger<V> 
- Phaser

**Executors**

Содержит в себе отличные фрейморки для создания пулов потоков, планирования работы асинхронных задач с получением результатов.

- Future<V>
- Callable<V>
- Executor

**Locks**

Представляет собой альтернативные и более гибкие механизмы синхронизации потоков по сравнению с базовыми synchronized, wait, notify, notifyAll.

**Atomics**

Классы с поддержкой атомарных операций над примитивами и ссылками.

<!--
Атомики
Конкарентные коллекции
execution фреймворки
Как многопоточно отправить письма
CachedThreadPool
-->

--------------------

## 2. How to start a new thread?

```java
new Thread(() -> {
    System.out.println("Hello world from a thread!");
}).start();
```

--------------------

## 3. Describe thread states.

Можно создать поток в Java и запустить его, но как состояние потока меняется от **Runnable** в **Running** и в **Blocked** зависит от реализации **системного планировщика потоков** (Thread scheduler) и в Java **нет полного контроля** над этим процессом.

- **New:** В этом состоянии находится только что созданный объект класса *Thread*. В этом состоянии поток еще не работает.
- **Runnable:** В это состояние переводится состояние объекта *Thread* после вызова метода `start()`. При этом управление потоком передается *Планировщику потоков*.
- **Running:** В это состояние поток переводится когда он реально будет запущен планировщиком (когда начнёт выполнение).
- **Waiting:** В этом состоянии поток находится, когда ожидает другой поток.
- **Blocked:** В этом состоянии поток находится, когда ждет освобождения какого-либо ресурса.
- **Dead:** В этом состоянии поток находится после завершения своего выполнения.

![](/resources/data/blog/java-concurrency-questions/thread-states.png)

--------------------

## 4. What is `volatile` keyword for?

```java
private volatile int a;
```

Модификатор **volatile** накладывает некоторые дополнительные условия на чтение/запись переменной.

Важно понять две вещи о volatile переменных:

- Операции чтения/записи volatile переменной являются атомарными, но это не означает, например, атомарный инкремент.
- Результат операции записи значения в volatile переменную одним потоком, становится виден всем другим потокам, которые используют эту переменную для чтения из нее значения.

**volatile** обеспечивает только **видимость изменений**, а классы **AtomicXXX** дают еще и **атомарность изменений**.

Простой пример - вам нужно проинкрементить счетчик и вернуть значение. Если поле счетчика будет обычным *volatile int* - возможна ситуация, когда два разных потока сначала проведут инкремент, а потом оба заберут результат двух инкрементов.
Если же взять **AtomicInteger**, будет гарантирована атомарность, и каждый поток получит правильный результат.

--------------------

## 5. Deadlocks. What is it? How to reproduce? How to prevent?

**Deadlock** – это событие, при котором два или более потока взаимно блокируют друг-друга, переводя программу в состояние вечного ожидания.

Как воспроизвести:

Deadlock на примере двух потоков и двух ресурсов:

- **THREAD1** лочит ресурс **LOCK1**.
- **THREAD2** лочит ресурс **LOCK2**.
- **THREAD1** пытается залочить ресурс **LOCK2** (не может, т.к. он залочен **THREAD2**).
- **THREAD2** пытается залочить ресурс **LOCK1** (не может, т.к. он залочен **THREAD1**).

```java
private void deadlock() {
    Object lock1 = new Object();
    Object lock2 = new Object();
    new Thread(() -> {
        synchronized (lock1) {
            sleep5sec();
            synchronized (lock2) {
                System.out.println("Thread 1");
            }
        }
    }).start();
    new Thread(() -> {
        synchronized (lock2) {
            sleep5sec();
            synchronized (lock1) {
                System.out.println("Thread 2");
            }
        }
    }).start();
}
```

Как предотвратить:

Достаточно **лочить ресурсы** во всех потоках в **заранее определённом порядке**, например: сначала LOCK1, затем LOCK2.

--------------------

## 6. Differences between parallel executions and multithreading.

To be done.

--------------------

## 7. `Mutex`, `Monitor`, `Semaphore`.

**Mutex**

флаг, который может находиться в двух состояниях: **занят** или **не занят**. Напрямую недоступен для разработчика. Чтобы использовать **Mutex** – нужно использовать **Monitor**.

**Monitor**

надстройка над **Mutex** доступная разработчику через ключевое слово **synchronized** (можно написать в определении метода, а можно использовать как отдельный блок в коде).
Когда мы используем ключевое слово **synchronized**, то тот кусок кода или тело метода при компиляции обрамляется специальным кодом:

```
// --- [ BEFORE ] -----------
sunchronized (lock) {
    // ... some code ...
}

// --- [ AFTER ] -------------
// Если Mutex занят, то ждём освобождения,
// иначе захватываем Mutex.
// ... some code ...
// Освобождаем Mutex

```

Тут **lock** – это любой объект. Например: `Object lock = new Object();`.
Если **synchronized** используется для **метода**, то используется **Mutex** объекта текущего класса, например: `MyClass.class`.

**Semaphore**

это отдельный класс в пакете `java.util.concurrent`. Содержит настраиваемый **счётчик**, значение которого **равняется кол-ву потоков**, которым можно **одновременно пользоваться ресурсом**.
При захвате потоком ресурса счётчик семафора **декрементится**, при освобождении **инкрементится**. Если **значение счётчика == 0**, то новые потоки **будут ожидать** освобождения.

**P.S.** *Mutex* == *Semaphore(counter=1)*.
