## Spring

это целый набор фреймворков, решающих те или иные задачи.

**Spring Core**

Основной модуль фреймворка, обеспечивает основные функции фреймворка – DI, IoC.
Есть так называемый **ApplicationContext** – это набор бинов, которые нужны для работы программы. Мы сами указываем какие объекты попадут в **ApplicationContext**, и можем задавать это при помощи java-кода, XML или аннотаций. Эти бины будут участвовать при DI, Spring сам будет инжектить их.

**Spring MVC**

Логика работы **Spring MVC** построена вокруг **DispatcherServlet** – он обрабатывает все HTTP-запросы и отдает ответы.
Также, для веб-приложения нужен `WebApplicationContext`, который **extends** от `ApplicationContext` в котором есть некоторые дополнения, нужные для работы web-приложений.

![](/resources/data/blog/java-technologies/dispatcher-servlet.png)

- Шаг 1: `DispatcherServlet` обращается к интерфейсу `HandlerMapping`, который определяет какой контроллер должен быть вызван.
- Шаг 2: Контроллер принимает запрос и вызывает соответствующий метод.
- Шаг 3: `DispatcherServlet` при помощи интерфейса `ViewResolver` определяет какую вьюшку нужно показать.
- Шаг 4: `DispatcherServlet` отправляет данные модели в виде атрибутов во вьюшку, вьюшка рендерится и отдаётся в браузер.

**Spring Data**

дополнительный удобный механизм для взаимодействия с сущностями базы данных, организации их в репозитории, извлечение данных, изменение, в каких то случаях для этого будет достаточно объявить интерфейс и метод в нем, без имплементации.

Шаги для использования Spring Data:

- Наследовать свой интерфейс от одного из **интерфейсов Spring Data**, например от `CrudRepository`.
- Заинжектить интерфейс в сервис и уже можно использовать.

Сходу доступны базовые методы `CrudRepository`, например: `save`, `findById`, `delete`.
Однако можно писать более сложные методы, например:

```
List<Employees> findFirst5ByFirstNameStartsWithOrderByFirstName(String firstNameStartsWith);
```
Причем это всё помещается в интерфейс и всё работает "само".

--------------------

## Git

To be done

--------------------

## Maven

To be done

--------------------

## Gradle

To be done

--------------------

## POM

To be done

--------------------

## JPA

JPA (Java Persistence API) – это *спецификация*, описывающая возможность *сопоставлять объеты Java на таблицы* в базе данных.
JPA - это спецификация, т.е. описание того, как это должно происходить.
Одним из примеров реализации является Hibernate. Ещё есть *OJB*, *Toque*, *Castor*, и множество других.

--------------------

## Hibernate

**Hibernate** – реализация спецификации **JPA**. Hibernate является ORM-кой, т.е. **сопоставляет Java классы на записи в таблицах Б.Д.**
Тем самым сильно **упрощая работу с базой данных**, т.к. нет необходимости вручную писать SQL запросы и следить за целостностью данных в БД.
Также Hibernate предлагает инструменты для **автогенерации схемы базы данных** на основе конфигурации проекта.
Конфигурировать можно как при помощи **XML**, так и при помощи **аннотаций**.

**Уровни кeширования**

- Кеш первого уровня: Всегда привязан к **объекту сессии**. Hibernate всегда по умолчанию использует этот кеш и его нельзя отключить. Кеширует загружаемые объекты (не будет 2 раза загружать один и тот же объект).
- Кеш второго уровня: Привязан к **объекту-фабрике сессий** (Session Factory object). Кеширует примерно также, только работает для любых объектов сессии, а не для одного. Hibernate сам не реализует Second-Level Cache как таковое, а лишь предоставляет структуру для его реализации (например, ehcache). По умолчанию отключен.
- Кеш запросов: Кеш запросов похож на кеш второго уровня. Но в отличии от него - **ключом выступает не идентификатор объекта, а совокупность параметров запроса**. По умолчанию отключен.

**Преимущества**

- Ускоряет разработку, т.к. берет на себя выполнение большой части работы.
- Позволяет с небольшими усилиями или вообще без усилий менять СУБД.

**Недостатки**

- Необходимо уметь грамотно использовать ORM, знать как она работает под капотом, иначе можно стокнуться с ошибками и неоптимальным выполнением (проблема N+1).
- Работает значительно медленнее, чем если делать ту же задачу вручную, т.к. становится доступно написание более эффективных запросов.
- Плохо подходит для проектов, где требуется более серьёзной работы с БД, нежели CRUD запросы.

--------------------

## Servlet

**Servlet** - это интерфейс Java, реализация которого расширяет функциональные возможности сервера. Сервлет взаимодействует с клиентом посредством запросов и ответов.
Для веб-серверов есть **HTTP-специфичные** сервлеты из пакета `javax.servlet.http.HttpServlet`.

Каркас сервлета:

```
public class MainServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, 
                         HttpServletResponse resp) 
            throws ServletException, IOException {
        super.doGet(req, resp);
    }

    @Override
    protected void doPost(HttpServletRequest req,
                          HttpServletResponse resp) 
            throws ServletException, IOException {
        super.doPost(req, resp);
    }
}
```

--------------------

## Tomcat

**Tomcat** – это опенсурсный контейнер сервлетов. Реализует спецификацию **Servlet**, спецификацию JavaServer Pages (**JSP**) и некоторые другие.

Tomcat используется в качестве самостоятельного веб-сервера, в качестве сервера контента в сочетании с веб-сервером Apache HTTP Server, а также в качестве контейнера сервлетов в серверах приложений **JBoss** и **GlassFish**.

Для конфигурирования используется **web.xml**, деплоить WAR-ник можно как вручную перетащив файл, так и при помощи веб-интерфейса, и инструментов автоматического деплоя (через IDEA интеграцию с Tomcat). 

--------------------

## JSP

**JSP** (JavaServer Pages) – технология, позволяющая создавать содержимое, которое имеет как статические, так и динамические компоненты. 

Страница JSP содержит код двух типов:

- Статический код форматов HTML, SVG, WML или XML.
- Динамические вставки (напр. JSP-теги или вставки Java-кода), которые конструируют динамическое содержимое.

Наиболее употребимые теги с конструкции:

- Подключаем библиотеку тегов
```
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
```

- Подключаем другой файл JSP
```
<jsp:include page="partials/header.jsp"/>
```

- Цикл for и указание типа бина
```
<c:forEach items="${resumes}" var="resume">
    <jsp:useBean id="resume" type="ru.dipech.basejava.model.Resume"/>
    ...
</c:forEach>
```

- Вывод данных из бина и условие if
```
<h1>Resume: ${resume.fullName}</h1>
<small>UUID: ${resume.uuid}</small>
<c:if test="${not empty resume.contacts}">
    <h2>Contacts</h2>
    ${HtmlHelper.printContact(contact, contactType)}
    ${not empty contact.url ? "not empty" : "empty"}
</c:if>
```

- Вставка данных напрямую из Java
```
<%= Experience.NOW.getYear() %>
```

--------------------

## Jar, War

**JAR** (Java Archive) – представляет собой ZIP-архив, в котором содержится часть программы на языке Java.

**WAR** – формат файла, описывающий как Web-приложение упаковывается в файл (JAR или ZIP) в соответствии со спецификацией **Java Servlet**.

--------------------

## Java NIO

**java NIO** (New I/O or Non-blocking I/O) – новое API для работы с файловой системой

Краткий список недостатков первой I/O API:

- Классу File **не хватало функциональности**. Например не было метода copy для копирования файла/каталога.
- В классе File определено **много методов, которые возвращают boolean**. В случае ошибки, **возвращалось false, а не бросалось исключение**, что затрудняло обнаружение и исправление ошибок.
- Класс File не предоставляет хорошей обработки символьных ссылок.
- Класс File обрабатывает файлы/каталоги неэффективно (проблемы с масштабированием);
- Класс File предоставляет доступ к ограниченному набору атрибутов файлов, который зачастую недостаточен.


Ключевые особенности NIO, призванные решить проблемы:

- Каналы и селекторы: NIO поддерживает различные типы каналов. Канал является абстракцией объектов более низкого уровня файловой системы (например, отображенные в памяти файлы и блокировки файлов), что позволяет передавать данные с более высокой скоростью. **Каналы не блокируются** и поэтому Java предоставляет еще такие инструменты, как селектор, который позволяет выбрать готовый канал для передачи данных, и сокет, который является инструментом для блокировки.
- Буферы: в Java 4 была введена **буферизация для всех классов-обёрток** примитивов (кроме Boolean). Появился абстрактный класс Buffer, который предоставляет такие операции, как clear, flip, mark и т.д. Его подклассы предоставляют методы для получения и установки данных.
- Кодировки: в Java 4 появились кодировки (java.nio.charset), кодеры и декодеры для отображения байт и символов Unicode.

--------------------

## Ehcache

**ehcache** – универсальная система распределённого кеширования для Java-приложений и сервлетов.

Это небольшое приложение, которое реализует кеш как **динамический (в оперативной памяти)**, так и **дисковый кеш**, причём изначально спроектированное для работы с кешами большого объёма и в распределённых системах.

Можно подключать, например, для кеширования результатов запроса в репозиторий. Например, при помощи аннотации `@Cacheable`. А сбрасывать кеш при помощи `@CacheEvict`.

Может использоваться в том числе как реализация кеширования 2-го уровня в Hibernate.

--------------------

## JNDI

**JNDI** (Java Naming and Directory Interface) – это API для доступа к службам имен и каталогов.

Простыми словами, JNDI позволяет искать службы независимым от ресурсов способом. Например: можно получать доступ к DB Connection Pool унифицированным способом в разных окружениях, всё что для этого нужно - это строка вида `java:comp/env/FooBarPool`, пихаемая в JNDI, а возвратится объект соединения.

JNDI может использоваться для получения данных, объектов, девайсов, файлов, директорий при помощи единого интерфейса.

--------------------

## Hamcrest

**Hamcrest** - это библиотека matcher-ов, которая помогает писать тесты.

Example JUnit теста с использованием Hamcrest:

```
public class HamcrestFirstTest {
    @Test
    public void stringsAreEquals() {
        String string = "azaza";
        assertThat(string, equalTo("ololo"));
        assertThat(string, anyOf(containsString("pe"), endsWith("za")));
    }
}
```

--------------------

## Jackson

Jackson – библиотека для работы с данными в формате JSON.

```
// Note: a default constructor, getters and setters should be presented!

@JsonProperty("Number")
private long id;

@JsonProperty("First Name")
private String name;

@JsonIgnore
private String ignored;
```

Alternatives: GSON

--------------------

## JAXB

**JAXB** – это инструмент для работы с XML. Позволяет перегонять Java объекты в XML и обратно.

--------------------

## JUnit

A useful and powerful library for writing unit tests.

## REST and SOAP

REST
============================

**REST** - набор архитектурных принципов построения веб-сервисов.

**REST-ful** - так говорят о сервисе, который старается соответсвовать REST-архитектуре.

- То, что нужно делать (CRUD) задаётся методом HTTP: **GET**, **POST**, **PUT**, **PATCH**, **DELETE**.
- Из URL адреса определяется над чем происходит действие (например: **/book/** или **/article/**).

Пример CRUD пользователей:
- **[C]** PUT /user — Добавить пользователя (данные в теле запроса)
- **[R]** GET /user — Вывести список всех пользователей
- **[R]** GET /user/3 — Вывести определённого пользователя
- **[U]** PATCH /user/3 – Изменить пользователя (данные в теле запроса)
- **[D]** DELETE /user/3 – Удалить пользователя

**SOAP** - протокол для обмена структурированными сообщениями в формате XML.

Если на какой-нибудь вечеринке вам зададут вопрос об основных различиях между подходами SOAP и REST, а неподалеку будет находиться привлекательный представитель противоположного пола, вот ответ на этот вопрос:

- SOAP активно использует XML для кодирования запросов и ответов, а также строгую типизацию данных, гарантирующую их целостность при передаче между клиентом и сервером. С другой стороны, запросы и ответы в REST могут передаваться в ASCII, XML, JSON или любых других форматах, распознаваемых одновременно и клиентом, и сервером. Кроме того, в модели REST отсутствуют встроенные требования к типизации данных. *В результате пакеты запросов и ответов в REST имеют намного меньшие размеры, чем соответствующие им пакеты SOAP*.
- В модели SOAP уровень передачи данных протокола HTTP является «пассивным наблюдателем», и его роль ограничивается передачей запросов SOAP от клиента серверу с использованием метода POST. Детали сервисного запроса, такие как имя удаленной процедуры и входные аргументы, кодируются в теле запроса. Архитектура REST, напротив, рассматривает уровень передачи данных HTTP как активного участника взаимодействия, используя существующие методы НТТР, такие как GET, POST, PUT и DELETE, для обозначения типа запрашиваемого сервиса. Следовательно, с точки зрения разработчика, *запросы REST в общем случае более просты для формулирования и понимания, так как они используют существующие и хорошо понятные интерфейсы HTTP*.
- Модель SOAP поддерживает определенную степень интроспекции, позволяя разработчикам сервиса описывать его API в файле формата Web Service Description Language (WSDL, язык описания веб-сервисов). Создавать эти файлы довольно сложно, однако это стоит затраченных усилий, поскольку клиенты SOAP могут автоматически получать из этих файлов подробную информацию об именах и сигнатурах методов, типах входных и выходных данных и возвращаемых значениях. С другой стороны, *модель REST избегает сложностей WSDL в угоду более интуитивному интерфейсу, основанному на стандартных методах HTTP, описанных выше*.
- В основе REST лежит концепция ресурсов, в то время как SOAP использует интерфейсы, основанные на объектах и методах. Интерфейс SOAP может содержать практически неограниченное количество методов; интерфейс REST, напротив, ограничен четырьмя возможными операциями, соответствующими четырем методам HTTP.

--------------------

## POJO

**POJO** (Plain Old Java Object) – простой Java-объект, не унаследованный от какого-то специфического объекта и не реализующий никаких служебных интерфейсов сверх тех, которые нужны для бизнес-модели.

Обычно POJO является класс, который:
- Имеет только приватные поля с геттерами и сеттерами.
- Имеет дефотного конструктора.
- Не наследуется от другого класса.
