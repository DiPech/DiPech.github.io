## Object-oriented Programming (OOP)

**Полиморфизм**

Возможность работать с объектами разных типов одинаково, если у них есть общий интерфейс. 

```
Cat cat = new Cat();
Dog dog = new Dog();
AnimalBarbershop barbershop = new AnimalBarbershop();
barbershop.shear(cat);
barbershop.shear(dog);
```

При этом поведение каждого конкретного объекта зависит от конкретной реализации.

```
Animal animal = new Cat();
animal.voice(); // "Meow"
```

Самое чудесное в полиморфизме - позволяет скрыть детали реализации и работать с объектом при помощи интерфейса:
```List<Animal> animals = new ArrayList<>()```

**Инкапсуляция**

Означает сокрытие реализации. Из клиентского кода видно только интерфейс класса (публичные поля и методы), и мы ничего не знаем о сокрытых методах (protected, private), которые как правило содержат основную логику работы класса.

**Наследование**

Механизм создания класса на основе родительского. При этом новый класс наследует некоторые данные и методы родитеского класса.

Помогает избежать дублирование кода для логически схожих (подходящих) сущностей.

**Абстрагирование**

> Спорный пункт, однако для полноты укажем и его

Принцип, согласно которому модель должна описываться теми характеристиками, которые важны для предметной области, а неважные можно отбросить.
Например, нужно запрограммировать класс Car:
Предметная область «Гонки» – важные характеристики: скорость, маневренность, вес, аэродинамика.
Предметная область «Грузоперевозки» – важные характеристики: грузоподъемность, длина хода, надёжность.

--------------------

## SOLID

**SOLID** – это аббревиатура, за каждой буквой которой скрывается отдельный принцип проектирования.

**Single Responsibility Principle**

> У класса должна быть только одина причина для изменения.

Основная суть заключается в том, что отдельно взятый класс должен делать что-то одно, какую-то вполне определенную вещь.

Если это класс `Employee`, хранящий данные сотрудника, то он не должен, например, заниматься генерацией резюме, для этого нужно выделить отдельный класс.

Если это класс `Car`, то не нужно мешать все свойства в одном классе, лучше разбить на отдельные составляющие (`Engine`, `Hull`, `Wheel`) и использовать композицию.

Если это класс `Camera` в инструменте моделирования, то она не должна заниматься изменением объекта класса `Model` и не должна зависеть от `Model` в целом.

**Open/Closed Principle**

> Расширяйте классы, но не изменяйте их первоначальный код.

Главная идея этого принципа в том, чтобы не ломать существующий код при внесении изменений в программу.
Класс можно назвать открытым, если он доступен для расширения. Например, у вас есть возможность расширить набор его операций или добавить к нему новые поля, создав собственный подкласс.
В то же время, класс можно назвать закрытым (а лучше сказать, законченным), если он готов для использования другими классами. Это означает, что интерфейс класса уже окончательно определён и не будет изменяться в будущем.

Паттерн «Стратегия» отлично иллюстрирует как нужно делать:
Вместо того, чтобы зашивать жёстко какой-то алгоритм в метод класса `if`-ами (например, расчёт стоимости доставки заказа `Order` в зависимости от типа доставки int `DeliveryType`), можно выделить отдельный класс интерфейс `Delivery`, реализовать конкретные классы, например, `CarDelivery` и `AirDelivery`, и передавать их в класс `Order`.
То-есть, по факту, мы расширили класс (открыт для расширения), но не меняли его (класс закрыт для изменения / завершён).

**Liskov Substitution Principle**

> Подклассы должны дополнять, а не замещать поведение базового класса.

Стремитесь создавать подклассы таким образом, чтобы их объекты можно было бы подставлять вместо объектов базового класса, не ломая при этом функциональности клиентского кода.

Принципы подстановки:

- Типы параметров метода подкласса должны совпадать или быть более абстрактными, чем типы параметров базового метода: Базовый класс содержит метод `feed(Cat c)`. Если в подклассе переопределить метод на `feed(Animal c)` - всё будет хорошо, т.к. `Animal` более абстрактный тип, но если переопределить на `feed(BengalCat bc)`, то сломается клиентский код, т.к. он более конкретный.
- Тип возвращаемого значения метода подкласса должен совпадать или быть подтипом возвращаемого значения базового метода: Базовый класс содержит метод `Cat buyCat();`. Если в подклассе переопределить метод на `BengalCat buyCat();`, то всё ок - т.к. возвратится всё тот же `Cat`, однако если переопределить как `Animal buyCat();` - то не ок, т.к. вместо покупки кота нас может ожидать покупка слона.
- Метод не должен выбрасывать исключения, которые не свойственны базовому методу: Типы исключений в переопределённом методе должны совпадать или быть подтипами исключений, которые выбрасывает базовый метод, иначе в клиентский код не сможет отловить исключения, которые он не ожидает от этого кода.
- Еще куча принципов, но их знать не сильно обязательно, т.к. в Java они по большей части не реализуемы т.к. компилятор пошлёт в баню, этим недостаткам подвержены более слабо типизированные языки, где такое можно сделать в принципе.

**Interface Segregation Principle**

> Клиенты не должны зависеть от методов, которые они не используют.

Стремитесь к тому, чтобы интерфейсы были достаточно узкими, чтобы классам не приходилось реализовывать избыточное поведение.

Если интерфейс можно разбить на 2 самодостаточных интерфейса - это нужно сделать, иначе будет нарушен принцип единственной ответственности, либо придётся оставлять пустые реализации в ненужных методах.

**Dependency Inversion Principle**

> Классы верхних уровней не должны зависеть от классов нижних уровней. Оба должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

Обычно при проектировании программ можно выделить два уровня классов:

- Классы нижнего уровня: Реализуют базовые операции вроде работы с диском, передачи данных по сети, подключения к базе данных и прочее.
- Классы высокого уровня: Содержат сложную бизнес-логику программы, которая опирается на классы низкого уровня для осуществления более простых операций.

НЕПРАВИЛЬНО:
В большинстве случаев сначала пишутся классы низкого уровня (взаимодействие с Б.Д., работа с FileSystem, работа с сестью, и т.д.
Затем пишутся классы высокого уровня, которые используют классы низкого уровня. При этом может оказаться так, что большая часть функциональности либо не нужна (нарушается YAGNI), либо не подходит для решения задач бизнес-логики (без комментариев, кодинг ради кодинга).

ПРАВИЛЬНО:
Сначала реализуем классы высокого уровня, при этом если нужны операции низкого уровня - определяем их как интерфейс и делаем реализацию-заглушку. Уже далее, делаем конкретную реализацию интерфейса и используем в проекте. При этом мы не пишем лишнюю логику, мы точно уверены, что данная функциональность подойдет для решения бизнес-задачи.

--------------------

## GRASP

**GRASP** (*General Responsibility Assignment Software Patterns*) – основные шаблоны (скорее принципы) распределения обязанностей в программном обеспечении.

-----

**Information Expert**

Информационный эксперт – это класс, который **обладает** всей **информацией**, необходимой для **выполнения** какого-либо **действия**.

Например: Есть классы `Order`, `OrderItem`, `Product`, `Delivery`. Класс `Order` содержит в себе массив из `OrderItem` и один `Delivery`, а `OrderItem` относится 1 к 1 к `Product`. И `Product`, и `Delivery` имеют цену. `OrderItem` содержит информацию о кол-ве данного товара в заказе.

Кто должен считать итоговую сумму по конкретному товару в заказе?
Класс `OrderItem`, т.к. он содержит информацию о кол-ве данного товара и цене  товара (см. класс `Product`).

Кто должен считать итоговую сумму по всему заказу?
Класс `Order`, т.к. он содержит информацию по товарам и по доставке.

Ошибки:

- Подсчитывать, например, итоговую сумму в одном месте, отдельном от этих классов, например где-нибудь в контроллере. Т.к. этот код может понадобиться где-нибудь еще, плюс контроллер не информационный эксперт и нужен для другого.
- Подсчитывать итоговую сумму целиком в `Order` (то есть бежать циклом по `OrderItem`). Правильно считать сумму по товару в `OrderItem`, потому что именно этот класс информационный эксперт в этом. Т.е. из класса `Order` должен быть вызов `OrderItem.getSum()`.
- Если же нельзя или нелогично напрямую расположить код расчета в классе `Order` или `OrderItem`, то нужно создать классы-обёртки, например, `OrderPriceCalculator` и `OrderItemPriceCalculator`.

**Creator**

Создатель – как ни странно, это объект который создаёт другие объекты.
Суть принципа заключается в том, что должны быть наделены возможностью создавать те объекты, которые

- Или содержат созданные объекты (напр.: `Order` создает и инициализирует `OrderItem` и `Delivery`).
- Или используют созданные объекты или записывает их куда-нибудь (напр.: в БД).
- Или знают как инициализировать данный объект (Напр.: паттерн «Builder»).

**Controller**

Контроллер – это класс, который принимает запрос от одного слоя приложения (например, от UI слоя), и делегирует обязанности другому слою (например, сервисному слою).

Контроллер отвечает на вопрос "Как в данном конкретном случае обрабатывать данный конкретный запрос, какие части системы нужно задействовать?".

Контроллер отдаленно напоминает паттерн «Фасад», т.к. фасад занимается тем, что обеспечивает облегченный доступ к целой куче скрытых за ним объектов.

**Low Coupling и High Cohesion**

Low Coupling – это принцип, согласно которому каждый класс должен иметь минимальное кол-во связей с другими классами.

High Cohesion – это принцип, согласно которому **внутри каждого класса все его отдельные части (поля и методы класса) должны быть тесно связаны между собой.

Low Coupling рассматривает классы как отдельные единицы и связи между ними.

High Cohesion рассматривает только один конкретный класс, и смотрит на его содержимое (поля, методы).

Что это значит:
Если классы сильно связаны (High Coupling), то это приводит к тому, что изменения в одном классе обязательно повлияют на изменения в другом классе. И мы не можем рассматривать каждый такой класс отдельно, т.к. он зависит от других классов. Получается лапша зависимостей между классами и работать с таким, поддерживать такое, а тем более тестировать такое очень сложно.
Если внутри класса все или большинство его составляющих имеют низкое зацепление (Low Cohesion), то это означает что класс выполняет слишком много обязанностей, т.е. нарушает Single Responsibility Principle (Принцип единственной ответственности). 
Низкое зацепление может означать, например, что в классе `Order` распологаются поля и методы для генерации накладной, поля и методы для закрепления заказа за менеджером по его обработке. Правильно будет разделить класс `Order` на `Invoice` (генерирует накладную по `Order`) и `OrderManager` (связь 1-к-1 `Order` и `Manager`).

Примечание:
Тотальное соблюдение Low Coupling приводит к нарушению High Cohesion, и наоборот. Важно соблюдать баланс между этими двумя принципами.
Для лучшего понимания рассмотрим два крайних примера:

- Low Coupling (100%), High Cohesion (0%): Это получится один God-класс (связей между классами вообще нет, т.к. класс один), который содержит в себе вообще всю логику.
- Low Coupling (0%), High Cohesion (100%): Это получатся очень маленькие классы (что в принципе хорошо, соблюдается SRP), но этих будет огромное количество и связей между этими классами будет еще большее количество.

**Pure Fabrication**

Обычно мы создаём классы, которые так или иначе относятся к предметной области (например, `Order`). Что делать, если нам нужно произвести какие-нибудь манипуляции с этим классом, допустим, сохранить в базу? Поместить в `Order` логику работы с базой не лучший выход, т.к. нарушается SRP и High Cohesion. Для этих целей создаётся **надуманный класс** (класс, которого нет в предметной области), который принимает `Order` и делает грязную работу, например, `OrderDao`. И `Order` чист, и SRP соблюден.

**Indirection**

Принцип гласит о том, что если одним классам или слоям системы требуется доступ к другим классам или другим слоям системы, то лучше прокидывать зависимости не напрямую, а при помощи посредника.

Посредником может служить, например, Фасад (если требуется логика), или DTO (если требуются данные). Или, например, Controller если требуются и то и другое.

--------------------

## ACID

Транзация – это набор последовательных операций с БД, которые следует рассматривать как единое целое, какую-то единую операцию.
Следовательно, транзакция может быть либо выполнена целиком (нет ошибок при выполнении каждой операции), либо не выполнена вообще (произошла ошибка на любом этапе). В последнем случае необходимо отменять результат предыдущих операций, которые были выполнены до ошибочной.

**ACID (Atomicity, Consistency, Isolation, Durability)**

это набор требований к транзациям.

- Atomicity (Атомарность): Никакая транзакция не должна быть зафиксирована частично. Либо целиком, либо никак.
- Consistency (Согласованность): По завершению транзакции в результате выполнения транзакции данные должны быть согласованы. Это может быть часть бизнес-логики, например, если выполняем перевод с баланса на баланс, то списанная сумма должна равняться полученной сумме. В процессе выполнения согласованность теряется, т.к. части транзакции выполняются последовательно, по-этому нужно рассматривать согласованность только по завершению транзакции.
- Isolation (Изолированность): На результат текущей транзакции не должны влиять другие выполняемые транзакции. Полное соблюдение требования крайне дорогое в реальном мире, по-этому есть различные уровни изоляции, они рассмотрены ниже.
- Durability (Устойчивость): Никакие факторы не должны влиять на результат выполенной транзакции: ни сбой дисков, ни обесточивание системы, ни переполнение памяти, потоп, и т.д.

--------------------

## KISS, YAGNI, DRY

**KISS** – keep it simple stupid. It means that you should do things as simple as possible.

**YAGNI** – you aren't gonna need it. It means that you shouldn't implement something until you need it.

**DRY** – don't repeat yourself. It means that you should write something only once. Create functions and classes, extract common logic, be happy.

--------------------

## Agile

To be done.

--------------------

## SCRUM

**Scrum entities**

- Product Backlog is the master list of work that needs to get done. maintained by the product owner or product manager. It is, essentially, the team’s ToDo list. The product backlog is constantly revisited, re-prioritized and maintained by the Product Owner.
- Sprint Backlog is the list of features, tasks and fixes, selected by the development team for implementation in the current sprint cycle. In the sprint planning meeting, the team chooses which items it will work on for the sprint from the product backlog.
- Increment (Sprint Goal) is the usable end-product from a sprint. It could be an installable build, for example.

**Scrum ceremonies**

- Backlog organisation: The product owner’s main jobs are to drive the product towards its product vision and have a constant pulse on the market and the customer. Therefore, he/she maintains this list using feedback from users and the development team to help prioritize and keep the list clean and ready to be worked on at any given time.

To be continued...

https://www.atlassian.com/agile/scrum

--------------------

## ORM

To be done

--------------------

## TDD

To be done

--------------------

## Testing

To be done

--------------------

## O-notation

To be done

